# Progress

Each day I use a different programming language.

## Day 1 - AWK

Awk can do functions and it is pretty nice to work with. :-)

## Day 2 - XSLT

Thanks @marek for the suggestion. :-)
It is hell to work with XSLT, extremely verbose, hard to debug; it only has naive recursion.
It is so easy to make mistakes with XML. :-(

## Day 3 - Fortran

Thanks @PetrFanta for the suggestion. :-)

Fortran could have nicer way of reading inputs and use its obscure formats.
Once the input was read into a string (2.5 hours), the rest was easy (1 hour).

## Day 4 - Minizinc

Because the task was about modeling constraints, I for once chose a suitable language.
Solution took only a couple minutes.

## Day 5 - (Free)Basic

Again, I had to parse input manually; I am getting better at this.
The task itself was just a natural progression of day 2.

## Day 6 - (Common)Lisp

Revising finger-counting and adapting FP principles to LISP.

## Day 7 - (SWI)Prolog

I had to reimplement day 5 in another language.
Hardest task so far because of the second part which required changing the way programs are running.

## Day 8 - (Free)Pascal

A simple task quite well suited for the language of my choice.

## Day 9 - Lua

Yet another variation on virtual machine; nothing hard, finished surprisingly fast.
Lua is actually very comfortable language to write programs in.

## Day 10 - Erlang

First half was beautiful, second half not as much.
I don't regret using Erlang, however the second part was not a great match for it.

## Day 11 - PHP(7)

I chose a language which I am very familiar with because there is hardly anything interesting on reimplementing the computer again.
Finally a language where I was happy to use OOP.

## Day 12 - Matlab (Octave)

A task which forces you to think and to look for symmetries.
I had problems with performance with the language of my choice which caused doubts in the solution.

## Day 13 - Ruby

IntCode was easy to reimplement, I only had to tweak the input and output.
Playing the game was challenging until I got to hacking the memory.

## Day 14 - Rust

Biggest struggle so far.
There are so many safety features in the language that they get in the way very often.
At least the compiler is helpful.

## Day 15 - JavaScript

I liked exploration tasks last year and this one was also nice and easy.
Finally using some algorithms (BFS).

## Day 16 - Ada

The first part was easy, the second needed a bit of clever approach.

## Day 17 - Go 

The first part was about implementation of IntCode again.
Second part was solved mostly manually; heuristics were just too dumb.

## Day 18 - C

The task was easy enough, however its complexity was in the huge state-space which needed to be searched through.
To speed up the computation I had to implement a trivial collision-free three-level HashMap.

# Pool of languages
* haskell
* python
* perl
* c
* c++
* ocaml
* mercury

* java
* kotlin
* scala
* groovy
* vala
* c#
